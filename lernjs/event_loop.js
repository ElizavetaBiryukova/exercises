//Что код выведет в консоли?
setTimeout(function timeout() {
    console.log('Таймаут');
}, 0);

let p = new Promise(function(resolve, reject) {
    console.log('Создание промиса');
    resolve();
});

p.then(function(){
    console.log('Обработка промиса');
});

console.log('Конец скрипта');

//Создание промиса
// Конец скрипта
// Обработка промиса
// Таймаут
// Изначально в стеке выполнения находится сам скрипт, поэтому сначала выполняется только он.

// В первой строке появляется setTimeout, который ставит переданный колбэк в очередь макрозадач (macrotask queue) на выполнение.

// После этого в переменную p запишется промис. Стоит отметить, что создание промиса в данном случае происходит синхронно. Это значит, что код из переданного колбэка выполнится прямо сейчас. В результате в консоль выведется 'Создание промиса'.

// Далее мы уведомляем потребителя then, что хотели бы выполнить переданную функцию после успешного выполнения промиса. Так как промис уже имеет состояние fulfilled (мы вызвали resolve() при его создании), колбэк из then будет немедленно передан в очередь микрозадач (microtask queue) на выполнение.

// В конце выполнения скрипта выведется 'Конец скрипта'.

// Скрипт является макрозадачей. Как мы уже знаем, после завершения каждой задачи опустошается очередь микрозадач. В ней находится только ранее переданный в then колбэк. В результате его выполнения в консоль выведется 'Обработка промиса'.

// Так как очередь микрозадач опустела, можно продолжить выполнять код из очереди макрозадач. Там сейчас находится только колбэк, который мы передавали setTimeout. После его выполнения выведется 'Таймаут'

console.log(1);

setTimeout(() => console.log(2));

Promise.resolve().then(() => console.log(3));

Promise.resolve().then(() => setTimeout(() => console.log(4)));

Promise.resolve().then(() => console.log(5));

setTimeout(() => console.log(6));

console.log(7);

// console.log(1);
// // Первая строка выполняется сразу и выводит `1`.
// // Очереди микрозадач и макрозадач на данный момент пусты.

// setTimeout(() => console.log(2));
// // `setTimeout` ставит переданный колбэк в очередь макрозадач
// // - содержимое очереди макрозадач:
// //   `console.log(2)`

// Promise.resolve().then(() => console.log(3));
// // В очередь микрозадач ставится колбэк, выводящий `3`
// // - содержимое очереди микрозадач:
// //   `console.log(3)`

// Promise.resolve().then(() => setTimeout(() => console.log(4)));
// // В очередь микрозадач ставится колбэк с `setTimeout`
// // - содержимое очереди микрозадач:
// //   `console.log(3); setTimeout(...4)`

// Promise.resolve().then(() => console.log(5));
// // В очередь микрозадач ставится колбэк, выводящий `5`
// // - содержимое очереди микрозадач:
// //   `console.log(3); setTimeout(...4); console.log(5)`

// setTimeout(() => console.log(6));
// // `setTimeout` ставит переданный колбэк в очередь макрозадач
// // - содержимое очереди макрозадач:
// //   `console.log(2); console.log(6)`

// console.log(7);
// // Тут же выводит `7`.
// Итак, получается, что:

// Числа 1 и 7 выводятся сразу же, так как они не используют очереди задач вообще.
// Далее после окончания основного потока кода срабатывает очередь микрозадач.
// Её содержимое: console.log(3); setTimeout(...4); console.log(5).
// Выведется 3 и 5, а setTimeout(() => console.log(4)) поставит в конец очереди макрозадач вывод 4.
// В очереди макрозадач получается теперь: console.log(2); console.log(6); console.log(4).
// Очередь микрозадач полностью выполнена, срабатывает очередь макрозадач. Она выведет 2, 6, 4.
// Получается вывод 1 7 3 5 2 6 4.

console.log(1);

setTimeout(() => console.log(2));

Promise.reject(3).catch(console.log);

new Promise(resolve => setTimeout(resolve)).then(() => console.log(4));

Promise.resolve(5).then(console.log);

console.log(6);

setTimeout(() => console.log(7),0);

// 1 6 3 5 2 4 7